# 一、防止程序崩溃
应重点识别和避免以下经典高风险问题：
- 空指针引用（Null/Uninitialized Pointer Dereference）
- 越界访问（数组/指针/迭代器/下标检查缺失）
- 栈溢出（深递归、巨型栈对象、未控递归）
- 重复释放/错误释放（Double Free、Use-After-Free、野指针）
- 资源泄漏（内存、文件句柄、GDI、套接字等未释放）
- 未初始化/未定义行为（UB：签名溢出、未设定初值使用）
- 异常处理缺失/吞异常（异常未捕获导致崩溃或状态不一致）
- 并发协同问题：
  - 数据竞争（Data Race）与条件竞争（Race Condition）
  - 死锁/活锁/优先级反转（锁顺序不一致、锁粒度过大）
  - 非原子读写、内存可见性问题（缺少 `atomic`/内存栅栏）
- 非法迭代器/游标使用（失效迭代器、迭代中修改容器导致崩溃）
- 线程生命周期与资源管理混乱（线程未 Join/Detach，析构期仍在访问）
- 跨平台/编译器差异导致的未定义行为（结构体对齐、字节序、宏差异）

检查要点（建议）：
- 对所有外部/系统/库调用检查返回值与错误码；失败路径应可控。
- 关键路径执行边界检查与空值判断；减少隐式转换的风险。
- 资源/内存采用 RAII 或智能指针管理（C++：`unique_ptr`/`shared_ptr`）。
- 并发使用明确的锁顺序与细粒度锁；避免在锁内做长耗时操作。
- 跨线程共享数据使用 `atomic` 或受控同步原语；避免裸共享可变状态。
- 对递归或深调用栈设置安全边界或改为迭代；避免栈上巨型对象。
- 统一异常策略：明确可抛/不可抛边界，避免跨模块未捕获异常。

# 二、性能问题

应重点识别以下常见性能陷阱：
- 大循环中执行重/阻塞操作（磁盘/网络 IO、数据库访问、睡眠等待）
- 频繁分配/释放内存或创建对象（导致碎片与 GC/分配器压力）
- 重复计算/缺少缓存（相同结果未缓存、重复排序/查找/解析）
- N+1 查询/逐项远程调用（可批量或预取的场景未合并）
- 热路径中的昂贵日志/正则/JSON 解析/字符串拼接
- 不合适的数据结构或复杂度（O(N^2)/嵌套循环可降维为 O(N log N)）
- 锁竞争/串行化过多（大范围互斥导致吞吐下降）
- 不必要的拷贝/深拷贝（可用移动语义/引用/视图替代）
- 资源加载过大或频繁（图片/模型/视频流未做懒加载或复用）
- 跨语言/跨进程边界调用过多（序列化/上下文切换开销显著）

优化建议（方向）：
- 用分析器（Profiler/火焰图）识别热点；先测量、再优化。
- 在热路径使用缓存/预计算；避免重复解析与转换。
- 选择合适数据结构与算法，关注时间/空间复杂度。
- 降低锁粒度并提高并发度；必要时采用无锁或读写锁方案。
- 批量化 IO/查询；异步化耗时操作并隔离 UI/主线程。
- 合理控制日志等级与频度；避免在热路径进行重字符串操作。

# 三、业务逻辑变更
应重点识别重大业务逻辑变更
- 比如修改判断条件，本来每个平台都要运行的代码被限定为单一平台才执行
- 其他引起业务逻辑大变更的代码

# 四、识别编译问题
应重点识别可能引入编译告警，错误的问题
- 引起新增编译报错的问题